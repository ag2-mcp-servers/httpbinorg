# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T03:31:52+00:00



import argparse
import json
import os
from typing import *
from typing import Optional

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity
from fastapi import Header
from starlette.requests import Request

app = MCPProxy(
    contact={
        'email': 'me@kennethreitz.org',
        'url': 'https://kennethreitz.org',
        'x-responsibleDeveloper': 'Kenneth Reitz',
        'x-responsibleOrganization': 'Kenneth Reitz',
    },
    description='A simple HTTP Request & Response Service.<br/> <br/> <b>Run locally: </b> <code>$ docker run -p 80:80 kennethreitz/httpbin</code>',
    title='httpbin.org',
    version='0.9.2',
    servers=[{'url': 'https://httpbin.org'}],
)


@app.get(
    '/absolute-redirect/{n}', tags=['redirect_management', 'url_redirect_operations']
)
def get_absolute_redirect__n(n: int):
    """
    Absolutely 302 Redirects n times.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/anything',
    tags=[
        'data_handling_operations',
        'http_request_processing',
        'request_information_extraction',
    ],
)
def delete_anything():
    """
    Returns anything passed in request data.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/anything',
    tags=[
        'data_handling_operations',
        'http_request_processing',
        'request_information_extraction',
    ],
)
def get_anything():
    """
    Returns anything passed in request data.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/anything',
    tags=[
        'data_handling_operations',
        'http_request_processing',
        'request_information_extraction',
    ],
)
def patch_anything():
    """
    Returns anything passed in request data.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/anything',
    tags=[
        'data_handling_operations',
        'http_request_processing',
        'request_information_extraction',
    ],
)
def post_anything():
    """
    Returns anything passed in request data.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put('/anything', tags=['data_handling_operations', 'http_request_processing'])
def put_anything():
    """
    Returns anything passed in request data.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.trace(
    '/anything',
    tags=[
        'data_handling_operations',
        'http_request_processing',
        'request_information_extraction',
    ],
)
def trace_anything():
    """
    Returns anything passed in request data.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/anything/{anything}', tags=['data_handling_operations', 'http_request_processing']
)
def delete_anything__anything(anything: str):
    """
    Returns anything passed in request data.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/anything/{anything}', tags=['data_handling_operations', 'http_request_processing']
)
def get_anything__anything(anything: str):
    """
    Returns anything passed in request data.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/anything/{anything}', tags=['data_handling_operations', 'http_request_processing']
)
def patch_anything__anything(anything: str):
    """
    Returns anything passed in request data.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/anything/{anything}', tags=['data_handling_operations', 'http_request_processing']
)
def post_anything__anything(anything: str):
    """
    Returns anything passed in request data.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/anything/{anything}', tags=['data_handling_operations', 'http_request_processing']
)
def put_anything__anything(anything: str):
    """
    Returns anything passed in request data.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.trace(
    '/anything/{anything}', tags=['data_handling_operations', 'http_request_processing']
)
def trace_anything__anything(anything: str):
    """
    Returns anything passed in request data.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/base64/{value}', tags=['base64_operations', 'data_handling_operations'])
def get_base64__value(value: str = 'SFRUUEJJTiBpcyBhd2Vzb21l'):
    """
    Decodes base64url-encoded string.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/basic-auth/{user}/{passwd}', tags=['user_authentication_methods'])
def get_basic_auth__user__passwd(user: str, passwd: str = ...):
    """
    Prompts the user for authorization using HTTP Basic Auth.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/bearer', tags=['user_authentication_methods', 'http_request_processing'])
def get_bearer(authorization: Optional[str] = Header(None, alias='Authorization')):
    """
    Prompts the user for authorization using bearer authentication.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/brotli', tags=['response_encoding_operations'])
def get_brotli():
    """
    Returns Brotli-encoded data.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/bytes/{n}', tags=['data_handling_operations', 'uuid_generation_operations'])
def get_bytes__n(n: int):
    """
    Returns n random bytes generated with given seed
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/cache',
    tags=[
        'http_request_methods',
        'http_request_processing',
        'etag_management',
        'status_code_handling',
        'response_header_operations',
    ],
)
def get_cache(
    if__modified__since: Optional[str] = Header(None, alias='If-Modified-Since'),
    if__none__match: Optional[str] = Header(None, alias='If-None-Match'),
):
    """
    Returns a 304 if an If-Modified-Since header or If-None-Match is present. Returns the same as a GET otherwise.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/cache/{value}', tags=['data_handling_operations', 'response_header_operations']
)
def get_cache__value(value: int):
    """
    Sets a Cache-Control header for n seconds.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/cookies', tags=['cookie_operations', 'data_handling_operations'])
def get_cookies():
    """
    Returns cookie data.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/cookies/delete',
    tags=['cookie_operations', 'redirect_management', 'url_redirect_operations'],
)
def get_cookies_delete(freeform: Optional[str] = None):
    """
    Deletes cookie(s) as provided by the query string and redirects to cookie list.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/cookies/set',
    tags=['cookie_operations', 'redirect_management', 'url_redirect_operations'],
)
def get_cookies_set(freeform: Optional[str] = None):
    """
    Sets cookie(s) as provided by the query string and redirects to cookie list.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/cookies/set/{name}/{value}',
    tags=['cookie_operations', 'redirect_management', 'url_redirect_operations'],
)
def get_cookies_set__name__value(name: str, value: str = ...):
    """
    Sets a cookie and redirects to cookie list.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/deflate', tags=['response_encoding_operations'])
def get_deflate():
    """
    Returns Deflate-encoded data.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete('/delay/{delay}', tags=['response_delay_management'])
def delete_delay__delay(delay: int):
    """
    Returns a delayed response (max of 10 seconds).
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/delay/{delay}', tags=['response_delay_management'])
def get_delay__delay(delay: int):
    """
    Returns a delayed response (max of 10 seconds).
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/delay/{delay}', tags=['response_delay_management', 'rate_limiting_handling']
)
def patch_delay__delay(delay: int):
    """
    Returns a delayed response (max of 10 seconds).
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/delay/{delay}', tags=['response_delay_management'])
def post_delay__delay(delay: int):
    """
    Returns a delayed response (max of 10 seconds).
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put('/delay/{delay}', tags=['response_delay_management'])
def put_delay__delay(delay: int):
    """
    Returns a delayed response (max of 10 seconds).
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.trace('/delay/{delay}', tags=['response_delay_management'])
def trace_delay__delay(delay: int):
    """
    Returns a delayed response (max of 10 seconds).
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete('/delete', tags=['http_request_methods', 'http_request_processing'])
def delete_delete():
    """
    The request's DELETE parameters.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/deny', tags=['robots_txt_management'])
def get_deny():
    """
    Returns page denied by robots.txt rules.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/digest-auth/{qop}/{user}/{passwd}', tags=['user_authentication_methods'])
def get_digest_auth__qop__user__passwd(qop: str, user: str = ..., passwd: str = ...):
    """
    Prompts the user for authorization using Digest Auth.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/digest-auth/{qop}/{user}/{passwd}/{algorithm}',
    tags=['user_authentication_methods'],
)
def get_digest_auth__qop__user__passwd__algorithm(
    qop: str, user: str = ..., passwd: str = ..., algorithm: str = 'MD5'
):
    """
    Prompts the user for authorization using Digest Auth + Algorithm.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/digest-auth/{qop}/{user}/{passwd}/{algorithm}/{stale_after}',
    description=""" allow settings the stale_after argument.
 """,
    tags=['user_authentication_methods'],
)
def get_digest_auth__qop__user__passwd__algorithm__stale_after(
    qop: str,
    user: str = ...,
    passwd: str = ...,
    algorithm: str = 'MD5',
    stale_after: str = 'never',
):
    """
    Prompts the user for authorization using Digest Auth + Algorithm.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/drip', tags=['response_delay_management', 'streaming_response_operations'])
def get_drip(
    duration: Optional[float] = 2,
    numbytes: Optional[int] = 10,
    code: Optional[int] = 200,
    delay: Optional[float] = 2,
):
    """
    Drips data over a duration after an optional initial delay.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/encoding/utf8', tags=['response_encoding_operations', 'data_handling_operations']
)
def get_encoding_utf8():
    """
    Returns a UTF-8 encoded body.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/etag/{etag}', tags=['etag_management', 'http_request_processing'])
def get_etag__etag(
    if__none__match: Optional[str] = Header(None, alias='If-None-Match'),
    if__match: Optional[str] = Header(None, alias='If-Match'),
    etag: str = ...,
):
    """
    Assumes the resource has the given etag and responds to If-None-Match and If-Match headers appropriately.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/get', tags=['http_request_processing', 'request_information_extraction'])
def get_get():
    """
    The request's query parameters.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/gzip', tags=['response_encoding_operations', 'data_handling_operations'])
def get_gzip():
    """
    Returns GZip-encoded data.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/headers', tags=['request_information_extraction', 'http_request_processing'])
def get_headers():
    """
    Return the incoming request's HTTP headers.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/hidden-basic-auth/{user}/{passwd}', tags=['user_authentication_methods'])
def get_hidden_basic_auth__user__passwd(user: str, passwd: str = ...):
    """
    Prompts the user for authorization using HTTP Basic Auth.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/html', tags=['response_format_handling'])
def get_html():
    """
    Returns a simple HTML document.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/image', tags=['response_format_handling', 'http_request_processing'])
def get_image():
    """
    Returns a simple image of the type suggest by the Accept header.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/image/jpeg', tags=['response_format_handling'])
def get_image_jpeg():
    """
    Returns a simple JPEG image.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/image/png', tags=['response_format_handling'])
def get_image_png():
    """
    Returns a simple PNG image.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/image/svg', tags=['response_format_handling'])
def get_image_svg():
    """
    Returns a simple SVG image.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/image/webp', tags=['response_format_handling'])
def get_image_webp():
    """
    Returns a simple WEBP image.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/ip', tags=['request_information_extraction'])
def get_ip():
    """
    Returns the requester's IP Address.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/json', tags=['response_format_handling'])
def get_json():
    """
    Returns a simple JSON document.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/links/{n}/{offset}', tags=['response_format_handling'])
def get_links__n__offset(n: int, offset: int = ...):
    """
    Generate a page containing n links to other pages which do the same.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch('/patch', tags=['http_request_processing', 'data_handling_operations'])
def patch_patch():
    """
    The request's PATCH parameters.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/post',
    tags=[
        'http_request_methods',
        'http_request_processing',
        'data_handling_operations',
    ],
)
def post_post():
    """
    The request's POST parameters.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/put',
    tags=[
        'http_request_methods',
        'data_handling_operations',
        'http_request_processing',
        'request_information_extraction',
    ],
)
def put_put():
    """
    The request's PUT parameters.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/range/{numbytes}',
    tags=['data_handling_operations', 'streaming_response_operations'],
)
def get_range__numbytes(numbytes: int):
    """
    Streams n random bytes generated with given seed, at given chunk size per packet.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete('/redirect-to', tags=['redirect_management', 'url_redirect_operations'])
def delete_redirect_to():
    """
    302/3XX Redirects to the given URL.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/redirect-to',
    tags=['redirect_management', 'url_redirect_operations', 'http_request_processing'],
)
def get_redirect_to(url: str, status_code: Optional[int] = None):
    """
    302/3XX Redirects to the given URL.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch('/redirect-to', tags=['redirect_management', 'url_redirect_operations'])
def patch_redirect_to():
    """
    302/3XX Redirects to the given URL.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/redirect-to',
    tags=['redirect_management', 'url_redirect_operations', 'http_request_processing'],
)
def post_redirect_to(request: Request):
    """
    302/3XX Redirects to the given URL.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/redirect-to',
    tags=['redirect_management', 'url_redirect_operations', 'http_request_processing'],
)
def put_redirect_to(request: Request):
    """
    302/3XX Redirects to the given URL.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.trace('/redirect-to', tags=['redirect_management', 'url_redirect_operations'])
def trace_redirect_to():
    """
    302/3XX Redirects to the given URL.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/redirect/{n}', tags=['redirect_management', 'url_redirect_operations'])
def get_redirect__n(n: int):
    """
    302 Redirects n times.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/relative-redirect/{n}', tags=['redirect_management', 'url_redirect_operations']
)
def get_relative_redirect__n(n: int):
    """
    Relatively 302 Redirects n times.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/response-headers', tags=['response_header_operations', 'http_request_processing']
)
def get_response_headers(freeform: Optional[str] = None):
    """
    Returns a set of response headers from the query string.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/response-headers', tags=['response_header_operations'])
def post_response_headers(freeform: Optional[str] = None):
    """
    Returns a set of response headers from the query string.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/robots.txt', tags=['robots_txt_management'])
def get_robots_txt():
    """
    Returns some robots.txt rules.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete('/status/{codes}', tags=['status_code_handling'])
def delete_status__codes(codes: str):
    """
    Return status code or random status code if more than one are given
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/status/{codes}', tags=['status_code_handling'])
def get_status__codes(codes: str):
    """
    Return status code or random status code if more than one are given
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch('/status/{codes}', tags=['status_code_handling'])
def patch_status__codes(codes: str):
    """
    Return status code or random status code if more than one are given
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/status/{codes}', tags=['status_code_handling'])
def post_status__codes(codes: str):
    """
    Return status code or random status code if more than one are given
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put('/status/{codes}', tags=['status_code_handling'])
def put_status__codes(codes: str):
    """
    Return status code or random status code if more than one are given
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.trace('/status/{codes}', tags=['status_code_handling', 'http_request_processing'])
def trace_status__codes(codes: str):
    """
    Return status code or random status code if more than one are given
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stream-bytes/{n}',
    tags=['streaming_response_operations', 'data_handling_operations'],
)
def get_stream_bytes__n(n: int):
    """
    Streams n random bytes generated with given seed, at given chunk size per packet.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stream/{n}', tags=['streaming_response_operations', 'response_format_handling']
)
def get_stream__n(n: int):
    """
    Stream n JSON responses
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/user-agent', tags=['request_information_extraction', 'user_agent_extraction']
)
def get_user_agent():
    """
    Return the incoming requests's User-Agent header.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/uuid', tags=['uuid_generation_operations'])
def get_uuid():
    """
    Return a UUID4.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/xml', tags=['xml_response_handling'])
def get_xml():
    """
    Returns a simple XML document.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
